**题目**：有一张用户签到表【user_attendence】，标记每天用户是否签到（说明：该表包含所有用户所有日期的签到记录） ，包含三个字段：日期【date】，用户id【user_id】，用户当天是否签到【is_sign_in：0否1是】

**问题1**：请计算**截至到最新日期**每个用户已经连续签到的天数（输出表仅包含当天签到的所有用户，计算其连续签到天数）

输出表【user_consecutive_days】:用户id【user_id】，用户联系签到天数【consecutive_days】



**问题2**：请计算每个用户历史以来最大的连续签到天数（输出表为用户签到表中所有出现过的用户，计算其历史最大连续签到天数）

输出表【user_max_days】:用户id【user_id】，用户最大连续签到天数【max_days】



问题1思路

根据题意，可以理解为表中最后一条记录是最新的日期，其实要求的就是最后一条记录往前推一直到is_sign_in字段为0的那一天，然后和最新日期求差值即为用户最近连续签到的天数。

举个例子，某个用户的签到情况如下：

[1，1，0，0，1，1，1，1，1，0，1，1，1，1]

根据题意用户最近连续签到了4天，其实就是从数组末尾往前推一直到遇到0。在sql中的实现为日期最大的0的日期和最新日期的差值。



问题1代码

```
select 
	user_id,
	from_timestamp() - max(date) as consecutive_days
from 
	user_attendence 
where 
	is_sign_in = 0
group by user_id
```



问题2思路

首先，如果用python做这个题是很简单的，直接遍历数组动态修改max_days变量即可。

看到网上的思路是把用户签到记录拼接成字符串，然后把字符串按0split，取最长的子字符串。

后面再想想有没有更好的办法吧。



（20200608）

受到[【问题记录】用户行为session按照指定间隔断开]笔记中同事思路的启发，我也想到了一个解决方法，不过比较偏门，也不知道是不是算得上是好方法：



| 用户签到记录 | 对签到记录取反（not） | 对取反后的签到记录使用sum()over() 得到key |
| ------------ | --------------------- | ----------------------------------------- |
| 1            | 0                     | 0                                         |
| 0            | 1                     | **1**                                     |
| 1            | 0                     | **1**                                     |
| 1            | 0                     | **1**                                     |
| 0            | 1                     | 2                                         |
| 1            | 0                     | 2                                         |

最后的结果是对key进行分组，然后求分组后collect_list()的长度，长度减去1就是要求的最大的连续签到天数。



再来看个例子：

| 用户签到记录 | 对签到记录取反（not） | 对取反后的签到记录使用sum()over() 得到key |
| ------------ | --------------------- | ----------------------------------------- |
| 0            | 1                     | 1                                         |
| 1            | 0                     | 1                                         |
| 0            | 1                     | **2**                                     |
| 1            | 0                     | **2**                                     |
| 1            | 0                     | **2**                                     |
| 1            | 0                     | **2**                                     |
| 1            | 0                     | **2**                                     |
| 0            | 1                     | 3                                         |



想到该方法也不是一下子就想到的，思考过程为：

尝试直接使用sum()over()——>发现签到的天数求和结果会递增，因此没法作为分组的依据——>尝试使用lag()over()——>好像没啥规律——>**问题的关键是构造出可以用来区分连续签到天数的key**——>尝试先取反然后sum()over() ——>有点接近了——>结果要减去1才是最终结果——>ok~~~