### 题目

（题目转载自知乎）

手机中的相机是深受大家喜爱的应用之一，下图是某手机厂商数据库中的用户行为信息表中部分数据的截图。

![img](https://pic1.zhimg.com/80/v2-aad91e183aa43e6a3f720fe9284caa5c_720w.jpg)

- 用户id：用户唯一标识；
- 应用名称：是手机中的某个应用，例如相机、微信、大众点评等。
- 启动时长：某一天中使用某应用多长时间（分钟）。
- 启动次数：某一天中启动了某应用多少次。
- 登陆时间：使用手机的日期。例如2018-05-01。

现在该**手机厂商**想要分析手机中的相机app的活跃情况，需统计如下数据：

某日活跃用户（用户id）在后续的一周内的留存情况（计算次日留存用户数，3日留存用户数，7日留存用户数）

指标定义：

某日活跃用户数，某日活跃的去重用户数。

N日活跃用户数，某日活跃的用户数在之后的第N日活跃用户数。

N日活跃留存率，N日留存用户数/某日活跃用户数

例：登陆时间（20180501日）去重用户数10000，这批用户在20180503日仍有7000人活跃，则3日活跃留存率为7000/10000=70%

所需获得的结果格式如下：

![img](https://pic2.zhimg.com/80/v2-b19c0bfa5c1322729ecc1c94309b4b25_720w.jpg)



### 我的思路

构造一个用户id对应的使用相机app日期的列表（表A）：

| id   | active_dates  |
| ---- | ------------- |
| A    | [date1,date2] |
| B    | [date2,date5] |

然后筛选出用户使用相机应用的日期（表B）：

**比如用户A在5.1，5.3，5.8三天使用了相机app**

| id   | app  | date |
| ---- | ---- | ---- |
| A    | 相机 | 5.1  |
| A    | 相机 | 5.3  |
| A    | 相机 | 5.8  |

把表Aleft join 表B，关联key为用户id，得到表C：

| id   | app  | date | active_dates  |
| ---- | ---- | ---- | ------------- |
| A    | 相机 | 5.1  | [5.1,5.3,5.8] |
| A    | 相机 | 5.3  | [5.1,5.3,5.8] |
| A    | 相机 | 5.8  | [5.1,5.3,5.8] |

对表C进行case when 判断，判断date 的次日、三日后、七日后是否在active_date列表中，如果在，则为1否则为0。得到表D:

| id   | app  | date | active_dates  | 次日是否活跃 | 三日后是否活跃 | 七日后是否活跃 |
| ---- | ---- | ---- | ------------- | ------------ | -------------- | -------------- |
| A    | 相机 | 5.1  | [5.1,5.3,5.8] | 0            | 0              | 1              |
| A    | 相机 | 5.3  | [5.1,5.3,5.8] | 0            | 0              | 0              |
| A    | 相机 | 5.8  | [5.1,5.3,5.8] | 0            | 0              | 0              |

然后对表D中的date进行分组



group by date 

- count(id) as "当日活跃用户数" (这里count 不需要加distinct是因为根据题意一个用户在一天内只有一条记录)
- sum(次日是否活跃) as "次日留存用户数"
- sum(三日后是否活跃) as “三日留存用户数“
- sum(七日后是否活跃) as “七日留存用户数“

留存率除一下即可。



### 其他可能的解答

使用自连接 （inner join） 还是拿上面的用户A举例，**用户A在5.1，5.3，5.8三天使用了相机app**，进行自连接后原本三条记录会变成3*3=9条记录：

```
SELECT
	a.id,
	a.app,
	a.date,
	b.date AS 'other_dates'
FROM
	(
		SELECT * FROM 用户行为信息表 WHERE app = '相机'
	)
	a
LEFT JOIN
	(
		SELECT * FROM 用户行为信息表 WHERE app = '相机'
	)
	b
ON
	a.id = b.id
```

| id   | app  | date | other_dates |
| ---- | ---- | ---- | ----------- |
| A    | 相机 | 5.1  | 5.1         |
| A    | 相机 | 5.1  | 5.3         |
| A    | 相机 | 5.1  | 5.8         |
| A    | 相机 | 5.3  | 5.1         |
| A    | 相机 | 5.3  | 5.3         |
| A    | 相机 | 5.3  | 5.8         |
| A    | 相机 | 5.8  | 5.1         |
| A    | 相机 | 5.8  | 5.3         |
| A    | 相机 | 5.8  | 5.8         |



comment: 其实这里和我用list的效果是一样的，但是我认为用list更好，因为记录条数更少，占用存储空间更少。

然后思路是对 date 和 other_dates两列求date_diff, 用case when 判断datediff是否等于1、3、7.

然后这里定义的留存率个人认为不太准确，因为留存率是针对新用户的。



















