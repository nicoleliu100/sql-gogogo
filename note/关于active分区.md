## ‘ACTIVE’分区的作用

一般在hive中建的表都是分区表，最常见的是全量表，只需要设置一个dt分区即可。

只有日期分区的表存在一个问题，如果这个表有消费方，并假设消费方在取数时取每日最新dt的数据，即每次都用dt=sysdate(-1)的限制条件去拿数据。

在当天任务结束前，dt=sysdate(-1)的数据并没有被生产出来，这时取数结果为空。更加合理的做法是如果当天数据还未生产，则应当取前一天的数据， 保证能取到数且取到的数是当前时刻最新即可。

要想实现上述逻辑，**如果只有日期分区**，那么下游取数时需要做额外的判断，即判断dt=sysdate(-1）的数据是否为空，然后才能决定到底要取今天的数还是昨天的数。但

是如果除了日期分区，额外增加一个‘ACTIVE’分区，保证‘ACTIVE’分区的数据始终为最新的数，这样下游直接取该分区内的数据即可，可以省去额外的判断逻辑。



## 实现方式

### 分区数量的选择

我一开始以为要建两个分区(dt, dp) ，dt用来存放每天的数据（如 dt=‘2020-05-26’），dp用来存放‘ACTIVE’。但是这样其实不太对。两个分区一般常见于具有层级关系的数据（这个说法有待考证），如日期分区和小时分区。

| dt           | dh   |
| ------------ | ---- |
| ‘2020-05-26’ | 12   |
| ‘2020-05-26’ | 13   |
| ‘2020-05-26’ | 14   |

关系类似于在文件夹（dt）中创建多个子文件夹（dh）。

但是上述‘ACTIVE’分区的需求和这个并不一样，‘ACTIVE’和普通的日期是处于同一层级的并列关系，因此只需要一个dt分区即可。把‘ACTIVE'当做一个每天值都会被修改的分区即可。（而其他日期的数据只会被生产一次，一般生产完成后便不会再修改了，除非sql逻辑有变化需要刷数。）

### 具体实现

我是这么实现的：

首先正常跑dt=sysdate(-1)的数据并插入对应的（sysdate(-1)分区），然后select 最新的日期分区的数据，**overwrite**到'ACTIVE'分区，这里一定要用overwrite，详细可以看另一篇笔记 insert overwrite和insert into的区别：

```
insert 
	overwrite table table_example partition 
	(
		dt
    )
    
select 
	*,
	'ACTIVE' as dt
from 
	table_example
where 
	dt = sysdate(-1)
```



